package completion.popup;

import static completion.CompletionPlugin.trace;

import java.awt.Component;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JList;
import javax.swing.SwingUtilities;

import org.gjt.sp.jedit.EditPane;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.gui.CompletionPopup;
import org.gjt.sp.jedit.textarea.JEditTextArea;

import completion.CompletionActions;
import completion.CompletionActions.CompletionMode;
import completion.service.CompletionCandidate;

public class Popup extends CompletionPopup
{
    private View view;
    private CompletionMode mode;
    private List<CompletionCandidate> completions;
    public int threadsRemaining;
    private boolean grabFocus;
    private boolean completeInstant;


    public Popup(View view, CompletionMode mode, boolean grabFocus, boolean completeInstant)
    {
        super(view,
            getLocation(view.getTextArea(), view.getTextArea().getCaretPosition(),
                getCompletionPrefix(view.getTextArea())));

        this.view = view;
        this.mode = mode;
        this.completions = new ArrayList<CompletionCandidate>();
        this.grabFocus = grabFocus;
        this.completeInstant = completeInstant;
    }

    public CompletionMode getMode ()
    {
        return mode;
    }

    /**
     * Some completions may not be provided instantly.  Add them when they arrive.
     * @param candidates
     */
    public void addCompletions (List<CompletionCandidate> candidates)
    {
        completions.addAll(candidates);
        threadsRemaining--;
        reset();
    }

    public void reset ()
    {
        List<CompletionCandidate> validCandidates = new ArrayList<CompletionCandidate>();
        String prefix = getCompletionPrefix(view.getTextArea());
        for (CompletionCandidate c :completions) {
            if (c.isValid(prefix)) {
                validCandidates.add(c);
            }
        }
        Candidates c = new Candidates(validCandidates);
        for (int i = 0; i < c.getSize(); i++) {
            trace(i + " " + c.getDescription(i) + " " + c);
        }

        if (threadsRemaining == 0 && completeInstant && completions.size() == 1) {
            completions.get(0).complete(getCompletionPrefix(view.getTextArea()), view);
        } else {
            reset(c, grabFocus);
        }
    }

    @Override
    protected void keyPressed(KeyEvent evt)
    {
        // These code should be reduced to make this popup behave
        // like a builtin popup. But these are here to keep
        // compatibility with the old implementation before
        // ractoring out of CompletionPopup.
        switch(evt.getKeyCode())
        {
        case KeyEvent.VK_ENTER:
            keyTyped('\n');
            evt.consume();
            break;
        case KeyEvent.VK_TAB:
            keyTyped('\t');
            evt.consume();
            break;
        case KeyEvent.VK_SPACE:
            evt.consume();
            break;
        case KeyEvent.VK_BACK_SPACE:
             if(getCompletionPrefix(view.getTextArea()) == "")
             {
                 dispose();
             }
             break;
        case KeyEvent.VK_DELETE:
            dispose();
            break;
        default:
            break;
        }
    }

    private void keyTyped(char ch)
    {
        // If no completion is selected, do not pass the key to
        // handleKeystroke() method. This avoids interfering
        // between a bit intermittent user typing and automatic
        // completion (which is not selected initially).
        int selected = getSelectedIndex();
        if(selected == -1)
        {
            view.getTextArea().userInput(ch);
            updateCompletion(false);
        }
        else if(handleKeystroke(selected, ch))
        {
            updateCompletion(true);
        }
        else {
            dispose();
        }
    }

    /**
     * @param selectedIndex The index of the selected completion.
     * @param keyChar the character typed by the user.
     * @return True if completion should continue, false otherwise.
     * @since SideKick 0.3.2
     */
    public boolean handleKeystroke(int selectedIndex, char keyChar)
    {
        // if(keyChar == '\t' || keyChar == '\n')
        if(CompletionActions.acceptChars.indexOf(keyChar) > -1)
        {
            completions.get(selectedIndex).complete(prefix, view)(view);
            insert(selectedIndex);
            if(SideKickActions.insertChars.indexOf(keyChar) > -1)
                textArea.userInput(keyChar);
            return false;
        }
        else
        {
            textArea.userInput(keyChar);
            return true;
        }
    }

    private void updateCompletion(boolean active)
    {
        SideKickCompletion newComplete = complete;
        EditPane editPane = view.getEditPane();
        JEditTextArea textArea = editPane.getTextArea();
        int caret = textArea.getCaretPosition();
        if(!newComplete.updateInPlace(editPane, caret))
        {
            newComplete = parser.complete(editPane, caret);
        }
        if(newComplete == null || newComplete.size() == 0)
        {
            dispose();
        }
        else
        {
            complete = newComplete;
            setLocation(getLocation(textArea, caret, complete));
            reset(new Candidates(), active);
        }
    }

    private static String getCompletionPrefix (JEditTextArea text, int caret)
    {
        return "";
    }

    private static String getCompletionPrefix (JEditTextArea text)
    {
        return getCompletionPrefix(text, text.getCaretPosition());
    }

    private static Point getLocation(JEditTextArea textArea, int caret, String completionPrefix)
    {
        Point location = textArea.offsetToXY(caret - completionPrefix.length());
        location.y += textArea.getPainter().getFontMetrics().getHeight();
        SwingUtilities.convertPointToScreen(location, textArea.getPainter());
        return location;
    }

    private class Candidates implements CompletionPopup.Candidates
    {
        private List<CompletionCandidate> validCandidates;

        public Candidates(List<CompletionCandidate> validCandidates)
        {
            this.validCandidates = validCandidates;
        }

        public int getSize()
        {
            return validCandidates.size();
        }

        public boolean isValid()
        {
            return true;
        }

        public void complete(int index)
        {
            validCandidates.get(index).complete(getCompletionPrefix(view.getTextArea()), view);
        }

        public Component getCellRenderer(JList list, int index,
            boolean isSelected, boolean cellHasFocus)
        {
            return validCandidates.get(index).getCellRenderer().getListCellRendererComponent(list, validCandidates.get(index).getDescription(), index, isSelected, cellHasFocus);
        }

        public String getDescription(int index)
        {
            return validCandidates.get(index).getDescription();
        }
    }
}